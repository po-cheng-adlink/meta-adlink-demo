From b32acb16cefcf1fc04b5843895d491ed04c253a0 Mon Sep 17 00:00:00 2001
From: "po.cheng" <po.cheng@adlinktech.com>
Date: Fri, 3 Feb 2023 14:56:10 +0800
Subject: [PATCH] hid-penmount: patch source code

Signed-off-by: po.cheng <po.cheng@adlinktech.com>
---
 drivers/hid/hid-penmount.c | 981 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 971 insertions(+), 10 deletions(-)

diff --git a/drivers/hid/hid-penmount.c b/drivers/hid/hid-penmount.c
index b9edc8e758fd..35b7efe3afea 100644
--- a/drivers/hid/hid-penmount.c
+++ b/drivers/hid/hid-penmount.c
@@ -1,38 +1,963 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
+ /*
  *  HID driver for PenMount touchscreens
  *
  *  Copyright (c) 2014 Christian Gmeiner <christian.gmeiner <at> gmail.com>
+ *  Copyright (c) 2021 John Sung <penmount <at> seed.net.tw>
  *
  *  based on hid-penmount copyrighted by
  *    PenMount Touch Solutions <penmount <at> seed.net.tw>
  */
 
 /*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
  */
 
 #include <linux/module.h>
 #include <linux/hid.h>
-#include "hid-ids.h"
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+#include <linux/input/mt.h>
+#endif
+
+//#define DRIVER_MT_SUPPORT     0
+
+#if !defined(DRIVER_MT_SUPPORT)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+#define DRIVER_MT_SUPPORT              1
+#else
+#define DRIVER_MT_SUPPORT              0
+#endif
+#endif
+
+#define PM_MAX_CONTACT                 10
+#define PM_DEF_CONTACT_P2_WIN8         10
+#define PM_DEF_CONTACT_PCI             5
+#define PM_DEF_CONTACT_6000            1
+#define PM_HID_REPORT_SIZE             5
+#define PM_HID_RAW_SIZE                128
+#define PM_HID_UPDATE_SIZE             512
+#define PM_HID_REPORT_ID               0x00
+
+#ifndef USB_VENDOR_ID_PENMOUNT
+#define USB_VENDOR_ID_PENMOUNT         0x14E1
+#endif
+
+#ifndef USB_DEVICE_ID_PENMOUNT_PCI
+#define USB_DEVICE_ID_PENMOUNT_PCI     0x3500
+#endif
+
+#ifndef USB_DEVICE_ID_PENMOUNT_6000
+#define USB_DEVICE_ID_PENMOUNT_6000    0x6000
+#endif
+
+#ifndef USB_DEVICE_ID_PENMOUNT_P2_WIN8
+#define USB_DEVICE_ID_PENMOUNT_P2_WIN8	0x3508
+#endif
+
+#ifndef ABS_MT_POSITION_X
+#define ABS_MT_POSITION_X              0x35    /* Center X ellipse position */
+#endif
+
+#ifndef ABS_MT_POSITION_Y
+#define ABS_MT_POSITION_Y              0x36    /* Center Y ellipse position */
+#endif
+
+#ifndef HID_DG_CONFIDENCE
+#define HID_DG_CONFIDENCE              (0x47 | HID_UP_DIGITIZER)
+#endif
+
+#ifndef HID_DG_CONTACTID
+#define HID_DG_CONTACTID               (0x51 | HID_UP_DIGITIZER)
+#endif
+
+#ifndef HID_DG_CONTACTCOUNT
+#define HID_DG_CONTACTCOUNT           (0x54 | HID_UP_DIGITIZER)
+#endif
+
+#ifndef HID_DG_SCANTIME
+#define HID_DG_SCANTIME               (0x56 | HID_UP_DIGITIZER)
+#endif
+//------------------------------------------------------
+// Version Information
+//------------------------------------------------------
+#ifndef PMDRIVER_MAJORVER
+#define PMDRIVER_MAJORVER 1
+#define PMDRIVER_MINORVER 19
+#define PMDRIVER_BUILDVER 2
+#define PMDRIVER_REVISION 0
+#define PMDRIVER_VERSION  ((PMDRIVER_MAJORVER<<12)|((PMDRIVER_MINORVER / 10)<<8)|((PMDRIVER_MINORVER % 10)<<4)|PMDRIVER_BUILDVER)
+#endif
+//------------------------------------------------------
+#define STATUS_CONNECTED 0x01
+#define STATUS_ACTIVE    0x02
+#define STATUS_ABNORMAL  0x04
+//------------------------------------------------------
+#define BSET(a,b) (a |=  b)
+#define BCLR(a,b) (a &= ~b)
+//------------------------------------------------------
+#define SCANTIME_CNT   2
+#define COLLECTION_CNT 2
+struct mt_slot {
+	unsigned char id;
+	unsigned short x, y;
+	unsigned char active; /* is the touch valid? */
+	unsigned char updated;
+	unsigned char valid;
+	unsigned short scantime;
+};
+
+struct penmount {
+	char version[32];
+	unsigned short model;
+	struct hid_device *hid;
+	struct input_dev *input;
+	unsigned char maxcontacts;
+	unsigned char report_id;
+	unsigned char read_size;
+	struct mt_slot slots[PM_MAX_CONTACT];
+	struct mt_slot curdata[COLLECTION_CNT];
+	unsigned char ack[PM_HID_REPORT_SIZE];
+	unsigned char finger_count;
+	unsigned char hybrid_mode;
+	unsigned short scantime[SCANTIME_CNT];
+	unsigned short st;
+	unsigned char st_idx;
+	unsigned char col;
+};
+
+int g_DebugLevel = 1;
+module_param_named(debug, g_DebugLevel, int, S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP | S_IROTH);
+
+int g_Status = 0;
+module_param_named(status, g_Status, int, S_IRUSR | S_IRGRP | S_IROTH);
+
+int g_VerMajor = PMDRIVER_MAJORVER;
+module_param_named(ver_major, g_VerMajor, int, S_IRUSR | S_IRGRP | S_IROTH);
+
+int g_VerMinor = PMDRIVER_MINORVER;
+module_param_named(ver_minor, g_VerMinor, int, S_IRUSR | S_IRGRP | S_IROTH);
+
+int g_VerBuild = PMDRIVER_BUILDVER;
+module_param_named(ver_build, g_VerBuild, int, S_IRUSR | S_IRGRP | S_IROTH);
+
+int g_VerRev = PMDRIVER_REVISION;
+module_param_named(ver_revision, g_VerRev, int, S_IRUSR | S_IRGRP | S_IROTH);
+
+static int penmount_hid_setreport(struct penmount *pm, int report_type, unsigned char *cmd, int length)
+{
+	int ret = 0;
+	int i = 0;
+	unsigned char * report = NULL;
+
+	report = kmalloc(length, GFP_KERNEL | __GFP_ZERO);
+	if (report == NULL) {
+		return -ENOMEM;
+	}
+
+	report[0] = pm->report_id;
+	for (i = 0; i < length; i++)
+		report[i+1] = cmd[i];
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)) || defined(HID_DG_BUTTONTYPE)
+	ret = hid_hw_raw_request(pm->hid, pm->report_id, report,
+		length+1, report_type, HID_REQ_SET_REPORT);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	ret = pm->hid->hid_output_raw_report(pm->hid, report,
+		length+1, report_type);
+#endif
+
+	if (ret < 0)
+		printk("[PENMOUNT] Failed to set %s report !\n", (report_type == HID_FEATURE_REPORT)?"feature":"output");
+
+	kfree (report);
+
+	return ret;
+}
+
+static int penmount_hid_getreport(struct penmount *pm, int report_type, unsigned char *ack, int length)
+{
+	int ret = -EINVAL;
+	int i = 0;
+	unsigned char * report = NULL;
+
+	report = kmalloc(length, GFP_KERNEL | __GFP_ZERO);
+	if (report == NULL) {
+		return -ENOMEM;
+	}
+
+	report[0] = pm->report_id;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)) || defined(HID_DG_BUTTONTYPE) || defined(HID_GROUP_RMI)
+	ret = hid_hw_raw_request(pm->hid, pm->report_id, report,
+		length+1, report_type, HID_REQ_GET_REPORT);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	ret = pm->hid->hid_get_raw_report(pm->hid, pm->report_id, report,
+		length+1, report_type);
+#endif
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get %s report !\n", (report_type == HID_FEATURE_REPORT)?"feature":"input");
+		kfree (report);
+		return ret;
+	}
+
+	for (i = 0; i < length; i++)
+		ack[i] = report[i+1];
+
+	kfree (report);
+	return ret;
+}
+
+static ssize_t penmount_cmd_store(struct device *dev,
+		struct device_attribute *attr, const char *buffer, size_t count)
+{
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	unsigned char cmd[PM_HID_REPORT_SIZE] = { 0, 0, 0, 0, 0 };
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL)
+		return -EINVAL;
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	sscanf(buffer, "%hhX %hhX %hhX %hhX %hhX", &cmd[0], &cmd[1],
+		&cmd[2], &cmd[3], &cmd[4]);
+
+	if (penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE) < 0)
+		return 0;
+
+	return count;
+}
+
+static ssize_t penmount_cmd_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	size_t count = 0;
+	unsigned char ack[PM_HID_REPORT_SIZE] = { 0, 0, 0, 0, 0 };
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL)
+		return -EINVAL;
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	if (penmount_hid_getreport(pm, HID_FEATURE_REPORT, ack, PM_HID_REPORT_SIZE) < 0)
+		return 0;
+
+	count = sprintf(buffer, "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n", ack[0],
+			ack[1], ack[2], ack[3], ack[4]);
+
+	return count;
+}
+
+static ssize_t penmount_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	size_t count = 0;
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL)
+		return -EINVAL;
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	count = sprintf(buffer, "%s\n", pm->version);
+
+	return count;
+}
+
+static ssize_t penmount_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buffer, size_t count) {
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	unsigned char cmd[PM_HID_REPORT_SIZE] = { 0xF1, 0, 0, 0, 1 };
+	unsigned char enable_state = 1;
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL)
+		return -EINVAL;
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	sscanf(buffer, "%hhX", &enable_state);
+
+	if (enable_state) {
+		cmd[0] = 0xF1;
+	} else {
+		cmd[0] = 0xF0;
+	}
+
+	if (penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE) < 0)
+		return 0;
+
+	return count;
+}
+
+static ssize_t penmount_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buffer) {
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	unsigned char enable_state = 1;
+	size_t count = 0;
+	unsigned char cmd[PM_HID_REPORT_SIZE] = { 0xE0, 0, 0xF0, 0, 0 };
+	unsigned char ack[PM_HID_REPORT_SIZE] = { 0, 0, 0, 0, 0 };
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL) {
+		return -EINVAL;
+	}
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	if (pm->model == USB_DEVICE_ID_PENMOUNT_6000)
+		return 0;
+
+	if (penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE) < 0)
+		return 0;
+
+	if (penmount_hid_getreport(pm, HID_FEATURE_REPORT, ack, PM_HID_REPORT_SIZE) < 0)
+		return 0;
+
+	if ((ack[4] & 0x03) == 0x03) {
+		enable_state = 1;
+	} else {
+		enable_state = 0;
+	}
+
+	count = sprintf(buffer, "%d\n", enable_state);
+
+	return count;
+}
+
+static ssize_t penmount_fw_store(struct device *dev,
+		struct device_attribute *attr, const char *buffer, size_t count) {
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	int length = 0;
+	char * str = (char *) buffer;
+	char * pch = NULL;
+	unsigned char fw[PM_HID_UPDATE_SIZE];
+	int i = 0;
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL)
+		return -EINVAL;
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	pch = strsep (&str," ");
+	while (pch != NULL) {
+		sscanf(pch, "%hhX", fw+length);
+		length++;
+		if (length >= PM_HID_UPDATE_SIZE) {
+			printk("[PENMOUNT] Ignoring update data > (%d)\n", length);
+			break;
+		}
+		pch = strsep (&str, " ");
+	}
+
+	if (g_DebugLevel) {
+		printk("[PENMOUNT] Update data (%d) : ", length);
+		for (i=0; i<length; i++) {
+			printk ("[0x%02X]", fw[i]);
+		}
+		printk ("\n");
+	}
+
+	penmount_hid_setreport(pm, HID_OUTPUT_REPORT, fw, length);
+
+	return count;
+}
+
+static ssize_t penmount_raw_show(struct device *dev,
+		struct device_attribute *attr, char *buffer) {
+	struct penmount *pm = NULL;
+	struct hid_device *hdev = NULL;
+	size_t count = 0;
+	int ret = 0;
+	int i = 0;
+	unsigned char * raw = NULL;
+	char str[5];
+
+	hdev = dev_get_drvdata(dev);
+	if (hdev == NULL) {
+		return -EINVAL;
+	}
+
+	pm = hid_get_drvdata(hdev);
+	if ((pm == NULL) || (buffer == NULL))
+		return -EINVAL;
+
+	raw = kmalloc(pm->read_size, GFP_KERNEL | __GFP_ZERO);
+	if (raw == NULL) {
+		return -ENOMEM;
+	}
+
+	ret = penmount_hid_getreport(pm, HID_FEATURE_REPORT, raw, pm->read_size);
+	for (i=0; i<pm->read_size; i++) {
+		sprintf(str, "0x%02X ", raw[i]);	
+		strcat (buffer, str);
+	}
+	kfree (raw);
+	
+	if (g_DebugLevel) {
+		printk("[PENMOUNT] Raw data (%d) : %s\n", pm->read_size, buffer);
+	}
+
+	count = strlen (buffer) + 1;
+	return count;
+}
+
+static DEVICE_ATTR(raw,    0444, penmount_raw_show,    NULL);
+static DEVICE_ATTR(fw,     0200, NULL,                 penmount_fw_store);
+static DEVICE_ATTR(ver,    0444, penmount_ver_show,    NULL);
+static DEVICE_ATTR(cmd,    0644, penmount_cmd_show,    penmount_cmd_store);
+static DEVICE_ATTR(enable, 0644, penmount_enable_show, penmount_enable_store);
+
+static struct attribute *penmount_attrs[] = {
+	&dev_attr_raw.attr,
+	&dev_attr_fw.attr,
+	&dev_attr_cmd.attr,
+	&dev_attr_ver.attr,
+	&dev_attr_enable.attr,
+	NULL
+};
+
+static const struct attribute_group penmount_attr_group = {
+	.attrs = penmount_attrs,
+};
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0 ,0)
+static int penmount_get_version(struct penmount *pm)
+{
+	int ret = 0;
+	unsigned short product_version = 0;
+	unsigned char major_version = 0;
+	unsigned char minor_version = 0;
+	unsigned char build_version = 0;
+	unsigned char odm_version = 0;
+	unsigned char cmd[PM_HID_REPORT_SIZE] = { 0xEE, 0, 0, 0, 0 };
+	unsigned char ack[PM_HID_REPORT_SIZE] = { 0, 0, 0, 0, 0 };
+
+	ret = penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version ! (1)\n");
+		return ret;
+	}
+
+	ret = penmount_hid_getreport(pm, HID_FEATURE_REPORT, ack, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version ! (2)\n");
+		return ret;
+	}
+
+	switch (pm->model) {
+	case USB_DEVICE_ID_PENMOUNT_P2_WIN8:
+	case USB_DEVICE_ID_PENMOUNT_PCI:
+		product_version = (ack[2] * 256 + ack[1]) & 0x7FFF;
+		major_version = ack[3];
+		break;
+	case USB_DEVICE_ID_PENMOUNT_6000:
+		product_version = ack[1] * 256 + ack[2];
+		major_version = ack[4];
+		break;
+	}
+
+	cmd[0] = 0xED;
+	ret = penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version !");
+		return ret;
+	}
+
+	ret = penmount_hid_getreport(pm, HID_FEATURE_REPORT, ack, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version !");
+		return ret;
+	}
+
+	switch (pm->model) {
+	case USB_DEVICE_ID_PENMOUNT_P2_WIN8:
+	case USB_DEVICE_ID_PENMOUNT_PCI:
+		minor_version = ack[1];
+		odm_version = ack[2];
+		build_version = ack[3];
+		break;
+	case USB_DEVICE_ID_PENMOUNT_6000:
+		minor_version = ack[2];
+		build_version = ack[4];
+		break;
+	}
+
+	if (!odm_version) {
+		sprintf(pm->version, "%d.%d.%d.%d", product_version,
+			major_version, minor_version, build_version);
+	} else {
+		sprintf(pm->version, "%d.D%02d.%d.%d.%d", product_version,
+			odm_version, major_version, minor_version,
+			build_version);
+	}
+	if (g_DebugLevel) printk("[PENMOUNT] Firmware version %s\n", pm->version);
+	return ret;
+}
+
+
+static int penmount_check_burst_read(struct penmount *pm)
+{
+	int ret = 0;
+	unsigned char cmd[PM_HID_REPORT_SIZE] = { 0xFA, 0, 0, 0, 0 };
+	unsigned char ack[PM_HID_REPORT_SIZE] = { 0, 0, 0, 0, 0 };
+	unsigned short report_size = 0;
+
+	if (pm->model == USB_DEVICE_ID_PENMOUNT_6000)
+		return -1;
+
+	ret = penmount_hid_setreport(pm, HID_FEATURE_REPORT, cmd, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version !");
+		return ret;
+	}
+
+	ret = penmount_hid_getreport(pm, HID_FEATURE_REPORT, ack, PM_HID_REPORT_SIZE);
+	if (ret < 0) {
+		printk("[PENMOUNT] Failed to get firmware version !");
+		return ret;
+	}
+
+	if (ack[0] == 0xAA) {
+		return 0;
+	}
+
+	report_size = (ack[2] * 256 + ack[1]) & 0x7FFF;
+	if (report_size) {
+		pm->read_size = report_size;
+		if (g_DebugLevel) printk("[PENMOUNT] Device supports burst read mode : %d bytes\n", pm->read_size);
+	}
+
+	return ret;
+}
+#endif
+
+static void penmount_send_event(struct penmount *pm)
+{
+#if DRIVER_MT_SUPPORT
+	int i;
+	int active;	
+	for (i = 0; i < pm->maxcontacts; ++i) {
+		input_mt_slot(pm->input, i);
+		input_mt_report_slot_state(pm->input, MT_TOOL_FINGER,
+				pm->slots[i].active);
+		active |= pm->slots[i].active;
+		input_event(pm->input, EV_ABS, ABS_MT_POSITION_X,
+			pm->slots[i].x);
+		input_event(pm->input, EV_ABS, ABS_MT_POSITION_Y,
+			pm->slots[i].y);
+		input_mt_sync(pm->input);
+	}
+	if (active) {
+		BSET(g_Status, STATUS_ACTIVE);
+	} else {
+		BCLR(g_Status, STATUS_ACTIVE);
+	}
+	input_mt_report_pointer_emulation(pm->input, true);
+#else
+	input_event(pm->input, EV_KEY, BTN_TOUCH, pm->slots[0].active);
+	input_event(pm->input, EV_ABS, ABS_X, pm->slots[0].x);
+	input_event(pm->input, EV_ABS, ABS_Y, pm->slots[0].y);
+#endif
+	input_sync(pm->input);
+}
+
+static
+void penmount_process_event(struct penmount *pm)
+{
+	int bSendEvent = 0;
+	unsigned char i = 0;
+
+	for (i = 0; i < COLLECTION_CNT; i++) {
+		if (!pm->curdata[i].valid) {
+			continue;
+		}
+		if (pm->curdata[i].id == 0x0A) {
+			// Notification
+			switch (pm->curdata[i].y >> 8) {
+			case 0:
+				BCLR(g_Status, STATUS_ABNORMAL);
+				// LEAVE
+				continue;
+			default:
+			case 0x02:
+				// ENTER
+				BSET(g_Status, STATUS_ABNORMAL);
+				continue;
+			}
+			continue;
+		}
+
+		if (pm->curdata[i].id >= pm->maxcontacts) {
+			continue;
+		}
+
+		pm->slots[pm->curdata[i].id].active = pm->curdata[i].active;
+		pm->slots[pm->curdata[i].id].x = pm->curdata[i].x;
+		pm->slots[pm->curdata[i].id].y = pm->curdata[i].y;
+
+		if (pm->hybrid_mode) {
+			pm->finger_count--;
+			if (!pm->finger_count) {
+				bSendEvent = 1;
+			}
+		} else if ((pm->slots[pm->curdata[i].id].updated) || (!pm->curdata[i].active)) {
+			bSendEvent = 1;			
+		} else {
+			pm->slots[pm->curdata[i].id].updated = 1;
+		}
+	}
+
+	if (bSendEvent == 0) {
+		return;
+	}
+
+	penmount_send_event(pm);
+
+	memset (pm->curdata, 0, sizeof(struct mt_slot) * COLLECTION_CNT);
+	if (pm->model == USB_DEVICE_ID_PENMOUNT_6000) {
+		pm->curdata[0].valid = 1;
+	}
+	for (i = 0; i < PM_MAX_CONTACT; i++) {
+		pm->slots[i].updated = 0;
+	}
+
+	return;
+}
+
+static int penmount_check_scantime(struct penmount *pm)
+{
+	int i = 0;
+
+	for (i = 0; i < SCANTIME_CNT; i++) {
+		if (pm->st == pm->scantime[i]) {
+			// found duplicate
+			printk ("[PENMOUNT] Warning ! Duplicated HID Input Report !\n");
+			return 0;
+		}
+	}
+	pm->st_idx = (pm->st_idx + 1) % SCANTIME_CNT;
+	pm->scantime[pm->st_idx] = pm->st;
+
+	return 1;
+}
+
+static int penmount_event(struct hid_device *hdev, struct hid_field *field,
+		struct hid_usage *usage, __s32 value)
+{
+	struct penmount *pm = (struct penmount *) hid_get_drvdata(hdev);
+
+	if (pm == NULL)
+		return 0;
+
+	if (pm->model == USB_DEVICE_ID_PENMOUNT_6000) {
+#if 0
+		/* Fallback to the generic hidinput handling */
+		return 0;
+#else
+		pm->curdata[0].id = 0;
+#endif
+
+	}
+
+	if (hdev->claimed & HID_CLAIMED_INPUT) {
+		switch (usage->hid) {
+		case HID_DG_CONTACTID:
+			pm->curdata[pm->col].id = value;
+			break;
+		case HID_UP_BUTTON | 0x0001:
+		case HID_DG_TIPSWITCH:
+			pm->curdata[pm->col].active = value;
+			break;
+		case HID_DG_CONFIDENCE:
+			pm->curdata[pm->col].valid = !!value;
+			break;
+		case HID_GD_X:
+			pm->curdata[pm->col].x = value;
+			break;
+		case HID_GD_Y:
+			pm->curdata[pm->col].y = value;
+			if (pm->model == USB_DEVICE_ID_PENMOUNT_P2_WIN8) {
+				pm->col = (pm->col + 1) % COLLECTION_CNT;
+			} else {
+				penmount_process_event(pm);
+			}
+			break;
+		case HID_DG_SCANTIME:
+			/* Fallback to the generic hidinput handling */
+			pm->st = value;
+			return 0;
+		case HID_DG_CONTACTCOUNT:
+			if (value) {
+				// first report
+				if (penmount_check_scantime(pm)) {
+					pm->finger_count = value;
+				} else {
+					printk ("CHECK SCANTIME [NG] !\n");
+					pm->finger_count = 0;
+				}
+			} else {
+				// continuous reports			
+			}
+			if (pm->finger_count) {
+				penmount_process_event(pm);
+			}
+			/* Fallback to the generic hidinput handling */
+			return 0;
+		default:
+			/* Fallback to the generic hidinput handling */
+			return 0;
+		}
+	}
+
+	if ((hdev->claimed & HID_CLAIMED_HIDDEV) && (hdev->hiddev_hid_event))
+		hdev->hiddev_hid_event(hdev, field, usage, value);
+
+	return 1;
+}
 
 static int penmount_input_mapping(struct hid_device *hdev,
 		struct hid_input *hi, struct hid_field *field,
 		struct hid_usage *usage, unsigned long **bit, int *max)
 {
-	if ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {
-		if (((usage->hid - 1) & HID_USAGE) == 0) {
-			hid_map_usage(hi, usage, bit, max, EV_KEY, BTN_TOUCH);
-			return 1;
-		} else {
-			return -1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+	struct penmount *pm = (struct penmount *) hid_get_drvdata(hdev);
+#endif
+
+	switch (usage->hid) {
+	case HID_GD_X:
+		if (DRIVER_MT_SUPPORT) {
+			hid_map_usage(hi, usage, bit, max, EV_ABS,
+				ABS_MT_POSITION_X);
+			input_set_abs_params(hi->input, ABS_MT_POSITION_X,
+				field->logical_minimum, field->logical_maximum,
+				0, 0);
+		}
+		hid_map_usage(hi, usage, bit, max, EV_ABS, ABS_X);
+		input_set_abs_params(hi->input, ABS_X, field->logical_minimum,
+				field->logical_maximum, 0, 0);
+		return 1;
+	case HID_GD_Y:
+		if (DRIVER_MT_SUPPORT) {
+			hid_map_usage(hi, usage, bit, max, EV_ABS,
+				ABS_MT_POSITION_Y);
+			input_set_abs_params(hi->input, ABS_MT_POSITION_Y,
+				field->logical_minimum, field->logical_maximum,
+				0, 0);
 		}
+		hid_map_usage(hi, usage, bit, max, EV_ABS, ABS_Y);
+		input_set_abs_params(hi->input, ABS_Y, field->logical_minimum,
+				field->logical_maximum, 0, 0);
+		return 1;
+	case HID_UP_BUTTON | 0x0001:
+		if (DRIVER_MT_SUPPORT) {
+		// PenMount 6000
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+			input_mt_init_slots(hi->input, pm->maxcontacts,
+				INPUT_MT_DIRECT);
+#elif DRIVER_MT_SUPPORT
+			input_mt_init_slots(hi->input, pm->maxcontacts);
+#endif
+		}
+		hid_map_usage(hi, usage, bit, max, EV_KEY, BTN_TOUCH);
+		input_set_capability(hi->input, EV_KEY, BTN_TOUCH);
+		return 1;
+	case HID_DG_TIPSWITCH:
+		hid_map_usage(hi, usage, bit, max, EV_KEY, BTN_TOUCH);
+		input_set_capability(hi->input, EV_KEY, BTN_TOUCH);
+		return 1;
+	case HID_DG_CONTACTID:
+		if (DRIVER_MT_SUPPORT) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+			input_mt_init_slots(hi->input, pm->maxcontacts,
+				INPUT_MT_DIRECT);
+#elif DRIVER_MT_SUPPORT
+			input_mt_init_slots(hi->input, pm->maxcontacts);
+#endif
+		}
+		return 1;
+	case HID_UP_BUTTON | 0x0002:
+	case HID_UP_BUTTON | 0x0003:
+		/* Ignore PenMount 6000 button 2 / 3, its value is always 0. */
+		return -1;
+	case HID_DG_CONFIDENCE:
+	case HID_DG_CONTACTCOUNT:
+	case HID_DG_SCANTIME:
+		return 1;
 	}
 
+	/* let hid-core decide for the others */
 	return 0;
 }
 
+static int penmount_input_mapped(struct hid_device *hdev, struct hid_input *hi,
+                 struct hid_field *field, struct hid_usage *usage,
+                 unsigned long **bit, int *max)
+{
+	if (field->application == HID_DG_TOUCHSCREEN ||
+	    field->application == HID_GD_MOUSE) {
+		if (usage->type == EV_KEY || usage->type == EV_ABS)
+			set_bit(usage->type, hi->input->evbit);
+		/* We own these mappings, tell hid-input to ignore them */
+		return -1;
+	}
+
+	/* let hid-core decide for the others */
+        return 0;
+}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+static void penmount_feature_mapping(struct hid_device *hdev,
+		struct hid_field *field, struct hid_usage *usage)
+{
+	struct penmount *pm = (struct penmount *) hid_get_drvdata(hdev);
+
+	if (pm == NULL)
+		return;
+
+	switch (usage->hid) {
+	case HID_DG_CONTACTMAX:
+		pm->maxcontacts = field->value[0];
+		/* field->value[0] value can be 0, in this case, use the
+			maximum value. */
+		if (!pm->maxcontacts)
+			pm->maxcontacts = field->logical_maximum;
+		break;
+	}
+
+	return;
+}
+#endif
+static
+int penmount_probe(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	struct penmount *pm = NULL;
+	struct hid_input *hidinput = NULL;
+	int ret = 0;
+	int i = 0;
+
+	pm = kmalloc(sizeof(struct penmount), GFP_KERNEL | __GFP_ZERO);
+	if (pm == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < SCANTIME_CNT; i++) {
+		pm->scantime[i] = 0xFFFF;
+	}	
+
+	hid_set_drvdata(hdev, pm);
+	pm->hid = hdev;
+	pm->model = id->product;
+	pm->report_id = PM_HID_REPORT_ID;
+	switch (id->product) {
+	case USB_DEVICE_ID_PENMOUNT_P2_WIN8:
+		pm->maxcontacts = PM_DEF_CONTACT_P2_WIN8;
+		pm->report_id = 0x01;
+		pm->hybrid_mode = 1;
+		break;
+	case USB_DEVICE_ID_PENMOUNT_PCI:
+		pm->maxcontacts = PM_DEF_CONTACT_PCI;
+		pm->curdata[1].valid = 0;
+		break;
+	default:
+	case USB_DEVICE_ID_PENMOUNT_6000:
+		pm->maxcontacts = PM_DEF_CONTACT_6000;
+		pm->curdata[0].valid = 1;
+		break;
+	}
+
+#if !DRIVER_MT_SUPPORT
+	printk ("[PENMOUNT] Device driver runs in single touch mode !\n");
+#endif
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		printk("[PENMOUNT] Failed to parse HID report !(%d)\n", ret);
+		kfree(pm);
+		return ret;
+	}
+
+	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (ret) {
+		printk("[PENMOUNT] Failed to start device !(%d)\n", ret);
+		kfree(pm);
+		return ret;
+	}
+
+	hidinput = list_entry(hdev->inputs.next, struct hid_input, list);
+	if (hidinput != NULL) {
+		hidinput->input->id.version = PMDRIVER_VERSION;
+		pm->input = hidinput->input;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+		set_bit(INPUT_PROP_DIRECT, hidinput->input->propbit);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+		// TODO: Warning sysfs_create_group() may trigger BUG in 2.6.32
+		if (sysfs_create_group(&hidinput->input->dev.kobj,
+				&penmount_attr_group)) {
+			printk("[PENMOUNT] Failed to create attr group !\n");
+		}
+#endif
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	penmount_get_version(pm);
+	penmount_check_burst_read(pm);
+#endif
+	if (g_DebugLevel) printk("[PENMOUNT] Device supports %d touch contacts !\n", pm->maxcontacts);
+	BSET(g_Status, STATUS_CONNECTED);
+	return ret;
+}
+
+static
+void penmount_remove(struct hid_device *hdev)
+{
+	struct penmount *pm = NULL;
+
+	if (g_DebugLevel) printk ("[PENMOUNT] Device removed !\n");
+	//BCLR(g_Status, STATUS_CONNECTED);
+	g_Status = 0;
+
+	pm = hid_get_drvdata(hdev);
+	if (pm != NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+		sysfs_remove_group(&pm->input->dev.kobj, &penmount_attr_group);
+#endif
+		kfree(pm);
+	}
+	hid_hw_stop(hdev);
+	hid_set_drvdata(hdev, NULL);
+
+	return;
+}
+
 static const struct hid_device_id penmount_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_6000) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_PCI) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_P2_WIN8) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, penmount_devices);
@@ -41,10 +966,46 @@ static struct hid_driver penmount_driver = {
 	.name = "hid-penmount",
 	.id_table = penmount_devices,
 	.input_mapping = penmount_input_mapping,
+	.input_mapped = penmount_input_mapped,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
+	.feature_mapping = penmount_feature_mapping,
+#endif
+	.probe = penmount_probe,
+	.remove = penmount_remove,
+	.event = penmount_event,
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 module_hid_driver(penmount_driver);
+#else
+static int __init penmount_init(void)
+{
+	printk ("[PENMOUNT] Loading %s V%d.%d.%d (R%d)\n", penmount_driver.name, PMDRIVER_MAJORVER, PMDRIVER_MINORVER, PMDRIVER_BUILDVER, PMDRIVER_REVISION);
+	return hid_register_driver(&penmount_driver);
+}
+
+static void __exit penmount_exit(void)
+{
+	hid_unregister_driver(&penmount_driver);
+
+	return;
+}
+
+module_init(penmount_init);
+module_exit(penmount_exit);
+#endif
+
+#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
+#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
+#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(PMDRIVER_MAJORVER, PMDRIVER_MINORVER)
+#define VER_PRODUCTVERSION_STR4(x)      VER_PRODUCTVERSION_STRING "." #x
+#define VER_PRODUCTVERSION_STR3(x)      VER_PRODUCTVERSION_STR4(x)
+#define VER_PRODUCTVERSION_STR2(x,y)    VER_PRODUCTVERSION_STRING "." #x "." #y
+#define VER_PRODUCTVERSION_STR1(x,y)    VER_PRODUCTVERSION_STR2(x, y)
+#define VER_PRODUCTVERSION_STR          VER_PRODUCTVERSION_STR1(PMDRIVER_BUILDVER, PMDRIVER_REVISION)
 
 MODULE_AUTHOR("Christian Gmeiner <christian.gmeiner@gmail.com>");
-MODULE_DESCRIPTION("PenMount HID TouchScreen driver");
+MODULE_AUTHOR("John Sung <penmount@seed.net.tw>");
+MODULE_DESCRIPTION("PenMount HID TouchScreen Driver");
 MODULE_LICENSE("GPL");
+MODULE_VERSION(VER_PRODUCTVERSION_STR);
-- 
2.25.1

